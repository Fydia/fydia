//! SeaORM Entity. Generated by sea-orm-codegen 0.2.3

use std::convert::TryFrom;

use fydia_struct::{
    instance::Instance,
    server::Servers,
    user::{User, UserId},
};
use sea_orm::{entity::prelude::*, sea_query::IntoCondition, Set};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "User")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "Text")]
    pub name: String,
    #[sea_orm(column_type = "Text", nullable)]
    pub instance: Option<String>,
    pub token: String,
    #[sea_orm(column_type = "Text")]
    pub email: String,
    #[sea_orm(column_type = "Text")]
    pub password: String,
    #[sea_orm(column_type = "Text", nullable)]
    pub description: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub server: Option<String>,
}

impl Model {
    pub fn to_user(&self) -> Result<User, String> {
        let db_servers = self
            .server
            .as_ref()
            .ok_or_else(|| String::from("No server in user"))?;
        let servers = Servers(serde_json::from_str(db_servers.as_str()).unwrap_or_default());

        Ok(User {
            id: UserId::new(self.id),
            name: self.name.clone(),
            description: self.description.clone(),
            email: self.email.clone(),
            instance: Instance::default(),
            token: Some(self.token.clone()),
            password: Some(self.password.clone()),
            servers,
        })
    }

    pub async fn get_model_by_id(id: &i32, executor: &DatabaseConnection) -> Result<Model, String> {
        match crate::entity::user::Entity::find_by_id(*id)
            .one(executor)
            .await
        {
            Ok(Some(model)) => Ok(model),
            _ => Err("No User with this id".to_string()),
        }
    }

    pub async fn get_model_by_token(
        token: &str,
        executor: &DatabaseConnection,
    ) -> Result<Model, String> {
        match crate::entity::user::Entity::find()
            .filter(crate::entity::user::Column::Token.contains(token))
            .one(executor)
            .await
        {
            Ok(Some(model)) => Ok(model),
            _ => Err("No User with this id".to_string()),
        }
    }

    pub async fn get_model_by<F>(
        condition: F,
        executor: &DatabaseConnection,
    ) -> Result<Model, String>
    where
        F: IntoCondition,
    {
        match crate::entity::user::Entity::find()
            .filter(condition)
            .one(executor)
            .await
        {
            Ok(Some(model)) => Ok(model),
            _ => Err("No User with this id".to_string()),
        }
    }
}

impl TryFrom<User> for ActiveModel {
    type Error = String;

    fn try_from(value: User) -> Result<Self, Self::Error> {
        let json = serde_json::to_string(&value.servers).map_err(|f| f.to_string())?;
        let instance_json = serde_json::to_string(&value.instance).map_err(|f| f.to_string())?;
        let password = value
            .password
            .clone()
            .ok_or_else(|| "Password is empty".to_string())?;

        Ok(Self {
            name: Set(value.name.clone()),
            token: Set(value.token.unwrap_or_default()),
            email: Set(value.email.clone()),
            password: Set(password),
            server: Set(Some(json)),
            instance: Set(Some(instance_json)),
            description: Set(value.description),
            ..Default::default()
        })
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::messages::Entity")]
    Messages,
    #[sea_orm(has_many = "super::server::Entity")]
    Server,
}

impl Related<super::messages::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Messages.def()
    }
}

impl Related<super::server::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Server.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
